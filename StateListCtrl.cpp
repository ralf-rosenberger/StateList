// StateListCtrl.cpp: Implementierungsdatei
//
// 1.0 written by Ralf Rosenberger Samstag, 28. September 2002
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "StateList.h"
#include "StateListCtrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BITMAPINFOHEADER bih = {40,36,16,1,4,0,320,0,0,16,0};

RGBQUAD rgb[] =
{
{0x00,0x00,0x00,0x00},
{0x00,0x00,0x80,0x00},
{0x00,0x80,0x00,0x00},
{0x00,0x80,0x80,0x00},
{0x80,0x00,0x00,0x00},
{0x80,0x00,0x80,0x00},
{0x80,0x80,0x00,0x00},
{0xC0,0xC0,0xC0,0x00},
{0x80,0x80,0x80,0x00},
{0x00,0x00,0xFF,0x00},
{0x00,0xFF,0x00,0x00},
{0x00,0xFF,0xFF,0x00},
{0xFF,0x00,0x00,0x00},
{0xFF,0x00,0xFF,0x00},
{0xFF,0xFF,0x00,0x00},
{0xFF,0xFF,0xFF,0x00}
};

BYTE data[] =
{0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,
0xDD,0xDD,0xDD,0x04,0x00,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,
0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0x20,0x03,0xDD,0xDD,0xDD,0xDD,0xDD,
0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xC5,0x00,
0xD3,0x33,0x33,0x33,0x33,0x33,0xDD,0xDD,0xDD,0xD3,0x33,0x33,0x33,0x33,0x33,
0xDD,0xDD,0xDD,0x02,0x00,0xD3,0xFF,0xFF,0xFF,0xFF,0xF3,0xDD,0xDD,0xDD,0xD3,
0xFF,0xFF,0xFF,0xFF,0xF3,0xDD,0xDD,0xDD,0x4E,0x00,0xD3,0xFF,0xFF,0xFF,0xFF,
0xF3,0xDD,0xDD,0xDD,0xD3,0xFF,0xF0,0xFF,0xFF,0xF3,0xDD,0xDD,0xDD,0x13,0x00,
0xD3,0xFF,0xFF,0xFF,0xFF,0xF3,0xDD,0xDD,0xDD,0xD3,0xFF,0x00,0x0F,0xFF,0xF3,
0xDD,0xDD,0xDD,0x02,0x00,0xD3,0xFF,0xFF,0xFF,0xFF,0xF3,0xDD,0xDD,0xDD,0xD3,
0xF0,0x00,0x00,0xFF,0xF3,0xDD,0xDD,0xDD,0x20,0x03,0xD3,0xFF,0xFF,0xFF,0xFF,
0xF3,0xDD,0xDD,0xDD,0xD3,0xF0,0x0F,0x00,0x0F,0xF3,0xDD,0xDD,0xDD,0x00,0x00,
0xD3,0xFF,0xFF,0xFF,0xFF,0xF3,0xDD,0xDD,0xDD,0xD3,0xF0,0xFF,0xF0,0x00,0xF3,
0xDD,0xDD,0xDD,0x02,0x00,0xD3,0xFF,0xFF,0xFF,0xFF,0xF3,0xDD,0xDD,0xDD,0xD3,
0xFF,0xFF,0xFF,0x00,0xF3,0xDD,0xDD,0xDD,0x20,0x03,0xD3,0xFF,0xFF,0xFF,0xFF,
0xF3,0xDD,0xDD,0xDD,0xD3,0xFF,0xFF,0xFF,0xF0,0xF3,0xDD,0xDD,0xDD,0xD3,0x01,
0xD3,0xFF,0xFF,0xFF,0xFF,0xF3,0xDD,0xDD,0xDD,0xD3,0xFF,0xFF,0xFF,0xFF,0xF3,
0xDD,0xDD,0xDD,0xC0,0x81,0xD3,0x33,0x33,0x33,0x33,0x33,0xDD,0xDD,0xDD,0xD3,
0x33,0x33,0x33,0x33,0x33,0xDD,0xDD,0xDD,0x20,0x03,0xDD,0xDD,0xDD,0xDD,0xDD,
0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xB5,0x00,
0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,
0xDD,0xDD,0xDD,0x02,0x00};

/////////////////////////////////////////////////////////////////////////////
// CStateListCtrl

CStateListCtrl::CStateListCtrl()
{
}

CStateListCtrl::~CStateListCtrl()
{
}


BEGIN_MESSAGE_MAP(CStateListCtrl, CListCtrl)
	//{{AFX_MSG_MAP(CStateListCtrl)
	ON_WM_PAINT()
	ON_NOTIFY_REFLECT(NM_CLICK, OnClick)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// Behandlungsroutinen fÃ¼r Nachrichten CStateListCtrl

void CStateListCtrl::OnPaint() 
{	
static bool bFirst = true;

	if(bFirst)
		{
		bFirst = false;

		m_imageListState.Create(bih.biWidth/2,bih.biHeight,ILC_COLOR16|ILC_MASK,0,0);

		const HANDLE hHeap = GetProcessHeap();
		BITMAPINFO *pbi;
		CPaintDC dc(this);

		pbi = (BITMAPINFO*)HeapAlloc(hHeap,HEAP_ZERO_MEMORY,sizeof(BITMAPINFOHEADER)+sizeof(rgb));
		if(!pbi)
			AfxThrowMemoryException();
		CopyMemory(&pbi->bmiHeader,&bih,sizeof(BITMAPINFOHEADER));
		CopyMemory(&pbi->bmiColors,&rgb,sizeof(rgb));

		HBITMAP hBitmap = CreateDIBitmap(dc.GetSafeHdc(),
										 &bih,
										 CBM_INIT,
										 data,
										 pbi,
										 DIB_RGB_COLORS);

		CBitmap bitmap;
		bitmap.Attach((HGDIOBJ)hBitmap);

		m_imageListState.Add(&bitmap,0xFF00FF);

		DeleteObject(bitmap.Detach());
		HeapFree(hHeap,0L,pbi);

		this->SetImageList(&m_imageListState,LVSIL_STATE);
		}

CListCtrl::OnPaint();
}

bool CStateListCtrl::SetCheck(int index,bool bCheck)
{
return SetItemState(index,bCheck ? LVIS_CHECKED:LVIS_UNCHECKED,LVIS_STATEIMAGEMASK) ? true:false;
}

bool CStateListCtrl::IsChecked(int index)
{
UINT uCheck = GetItemState(index,LVIS_STATEIMAGEMASK);
if(uCheck == LVIS_CHECKED)
	return true;

return false;
}

void CStateListCtrl::OnClick(NMHDR* pNMHDR, LRESULT* pResult) 
{
CPoint pt;

	DWORD dwPos = GetMessagePos();

	pt.x = LOWORD(dwPos);
	pt.y = HIWORD(dwPos);

	ScreenToClient(&pt);

	UINT uFlags;
	int index = HitTest(pt,&uFlags);
	if(index != -1 && uFlags & LVHT_ONITEMSTATEICON)
		{
		if(GetKeyState(VK_SHIFT) < 0)
			{
			int i = GetSelectionMark();

			int iStart = index < i ? index:i;
			int iEnd   = index < i ? i+1:index+1;

			for(i=iStart; i != iEnd; i++)
				SetCheck(i,IsChecked(i)^true);
			}
		else
			SetCheck(index,IsChecked(index)^true);
		}
	
	*pResult = 0;
}
